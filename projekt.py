# -*- coding: utf-8 -*-
"""Projekt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YRu6Om4NVN2KMP8nNqej73vzkVrACIM9

**Dennis Engelmark**

En hel del kod är från colabs guide för tidsserie som länkades i kursmodul 3

#Init
"""

# imports

import os
import datetime

import IPython
import IPython.display
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import tensorflow as tf
import keras

import keras_tuner
import sklearn

from keras import layers

from keras.regularizers import l2
from keras.layers import BatchNormalization

mpl.rcParams['figure.figsize'] = (8, 6)
mpl.rcParams['axes.grid'] = False

"""#Data (välj en)

Data baserat på 12 huvudkategorier i Sveriges KPI vilka är slentrianmässigt översatta nedan för att vara lagom enkla att anropa. Den vältränade märker säkert att det bara är 11 kategorier egenligen, detta beror på att en kategori har plockats bort eftersom den var tom - utbildning.

###KPI (obsolete)
"""

# Datum formaterade med magi i excell som också är en form av programmering 
url = 'https://raw.githubusercontent.com/engnisden/ml-dl-project/main/kpi_grouped3.csv'

#kpi_df = pd.read_csv(url, on_bad_lines='skip')
kpi_df = pd.read_csv(url, sep=';', skipinitialspace=True)

print(kpi_df.head(3))

print(msoft_df.head(3))

kpi_df.describe().transpose()
#kolla data

print(kpi_df['month'].head(3))

# convert to date or date time data type

date_time = pd.to_datetime(kpi_df['month'], format='%Y%m%d')

kpi_df['month'] = pd.to_datetime(kpi_df['month'], format='%Y%m%d')


print(type(kpi_df['month'][1]))

print(kpi_df['month'].head(3))

print(kpi_df['KPI'][150])

maxValues = kpi_df[['food', 'alcohol', 'living', 'housekeeping', 'healthcare', 'transport', 'comunications', 'recreations', 'restaurants', 'other']].max()
 
print(maxValues)
maxValueSet = maxValues.max() * 1.3
print(f'And the winner is: {maxValues.max()} and the roof for this laboration is {maxValueSet}')

kpi_df['month'] = date_time.map(pd.Timestamp.timestamp)

# time to split
# and apparantly it's good to normalize the data so i will try it

length = len(kpi_df['KPI'])

trainLength = length * 0.6
trainShort = length * 0.2
train = []
val = []
test = []

train = kpi_df[0:int(trainLength)]
val = kpi_df[int(trainLength):int(trainLength) + int(trainShort)]
test = kpi_df[int(trainLength) + int(trainShort):]

print(f'train length: {len(train)} val length: {len(val)} test length: {len(test)}')

train_mean = kpi_df.mean()
train_std = kpi_df.std() # standardavvikelse från medelvärdet

maxVal = kpi_df['healthcare'].max()


# Från början var detta bara ett slumpmässigt tal men är nu 30 % mer än det högsta i tabellen
arbitaryMax = maxValueSet


# vad får man om man tar bort medelvärdet ur en serie och dividerar med standaravvikelsen? Som Géron (2022) gör i sitt exempel.
# Vad är poängen? att få ett decimaltal i spannet -1 till 1? Är väl bara att divierada med max-värdet i så fall.
# men då blir ju max värdet det högsta möjliga. Så teoretiskt sett skulle man kunna dividera med 500 för att
# prediktering på kpi med maxvärdet 380~ skulle 500 innebära ungefär 1-2 år i hög inflationstakt. Vilket är 
# väldigt långt för en kpi prediktering som ändå är beroende av omvärldshändelser, vädret och dess moster.

# train = (train - train_mean) / arbitaryMax
# val = (val - train_mean) / arbitaryMax
# test = (test - train_mean) / arbitaryMax

train = train / arbitaryMax
val = val / arbitaryMax
test = test / arbitaryMax

count = 0
while count < 4:
  one = train['KPI'][count]
  two = val['KPI'][count + trainLength]
  three = test['KPI'][count + trainLength + trainShort]
  print(f'Datatest, train in slot {count} is: {one} val: {two} test: {three}')
  count += 1

num_features = kpi_df.shape[1]

"""###Microsoft stock

####Start
"""

# Datum formaterade med magi i excell som också är en form av programmering 
urlMicrosoft = 'https://raw.githubusercontent.com/engnisden/ml-dl-project/main/klar3.csv'
msoft_df = pd.read_csv(urlMicrosoft, sep=';', skipinitialspace=True)

url = 'https://raw.githubusercontent.com/engnisden/ml-dl-project/main/kpi_grouped3.csv'
kpi_df = pd.read_csv(url, sep=';', skipinitialspace=True)


kpi_df.rename(columns = {'KPI':'close', 'month':'date'}, inplace = True)

kpi_df.pop('food')
kpi_df.pop('alcohol')
kpi_df.pop('clothes')
kpi_df.pop('living')
kpi_df.pop('housekeeping')
kpi_df.pop('healthcare')
kpi_df.pop('transport')
kpi_df.pop('comunications')
kpi_df.pop('recreations')
kpi_df.pop('restaurants')
kpi_df.pop('other')
kpi_df.pop('plain_mean')

msoft_df.pop('adj_close')
msoft_df.pop('open')
msoft_df.pop('high')
msoft_df.pop('low')

# same format 

print(kpi_df.head(3))
# Tar bort volume så länge.
msoft_df.pop('volume')
print(msoft_df.head(3))

#date_time = pd.to_datetime(msoft_df.pop('date'), format='%Y%m%d %H:%M:%S')
#timestamp_s = date_time.map(pd.Timestamp.timestamp)

date_time = pd.to_datetime(msoft_df['date'], format='%Y%m%d %H:%M:%S')
timestamp_s = date_time.map(pd.Timestamp.timestamp)
msoft_df['date'] = date_time.map(pd.Timestamp.timestamp)

#msoft_df['date'] = pd.to_datetime(msoft_df['date'], format='%Y%m%d')

#msoft_df['date'] = timestamp_s

#print(msoft_df['date'].head(3))

day = 24*60*60
year = (365.2425)*day

#msoft_df['Day sin'] = np.sin(timestamp_s * (2 * np.pi / day))
#msoft_df['Day cos'] = np.cos(timestamp_s * (2 * np.pi / day))
#msoft_df['Year sin'] = np.sin(timestamp_s * (2 * np.pi / year))
#msoft_df['Year cos'] = np.cos(timestamp_s * (2 * np.pi / year))

print(msoft_df['close'][150])

maxValues = msoft_df[['close']].max()
maxValuesTest = kpi_df[['close']].max()

print(f'some testing: highest in train data {float(maxValues)} and highest in test: {float(maxValuesTest)}')
maxValueSet = maxValues.max() * 1.1
maxValueTestSet = maxValuesTest.max() * 1.1

print(f'Setting maximum training: {maxValueSet} and testing: {maxValueTestSet}')

# datatyps koll, växlar man tusentalsavgränasre och decimalavgränsare på fel sätt i excel så blir det en sträng eller float datatyp och här hade jag gjort fel
print(type(msoft_df['close'][14]))

# time to split
# and apparantly it's good to normalize the data so i will try it

length = len(msoft_df['close'])

trainLength = length * 0.7
trainShort = length * 0.2

train = []
val = []
test = []
final_test = []

train = msoft_df[0:int(trainLength)]
val = msoft_df[int(trainLength):int(trainLength) + int(trainShort)]
test = msoft_df[int(trainLength) + int(trainShort):]

print(f'train length: {len(train)} val length: {len(val)} test length: {len(test)}')


maxVal = msoft_df['close'].max()
# Från början var detta bara ett slumpmässigt tal men är nu 30 % mer än det högsta i tabellen
arbitaryMax = maxValueSet

# print(f'Dividing all data by {maxValueSet} as to normalize the data between -1 and 1')

"""####Normalisera enkel"""

# anpassat till en formel jag tyckte verkade logisk istället för standardavvikelse och medelvärden som passar värden inom vissa omfång
# men detta data har inga egent liga gränser så detta passar bättre. Används ej för tillfället
'''
train = (train - train.min()) / (train.max() - train.min())
val = (train - train.min()) / (train.max() - train.min())
test = (train - train.min()) / (train.max() - train.min())
'''

"""####Normalisera adv"""

train_mean = msoft_df.mean()
train_std = msoft_df.std() # standardavvikelse från medelvärdet

train = (train - train_mean) / train_std
val = (val - train_mean) / train_std
test = (test - train_mean) / train_std

# normalisera test-datat
# kan lika gärna köra all kpi-data som test data
#
# Tar bara de 24 sista värdena i kpi_df som test för att ha som input 
# sparar även dessa värden för att se vilka de är
# test = kpi_df[-24:]
test = kpi_df
savedTest = test
#test = kpi_df
test =  (test - kpi_df.mean()) / kpi_df.std()

# not used
reshapeOne = kpi_df.mean()
reshapeTwo = kpi_df.std()

final_test = kpi_df[len(kpi_df)-24:]
final_test =  (final_test - kpi_df.mean()) / kpi_df.std()

count = 0

num_features = msoft_df.shape[1]

"""##Datachecking"""

# columns to check
column1 = 'close'

print(f'length of train data frame: {len(train)}')
train.describe().transpose()

test

"""#Metoder

###Fönster
"""

# Från labb 3

class WindowGenerator():
  def __init__(self, input_width, label_width, shift,
               train_df=train, val_df=val, test_df=test, final_test_df=final_test,
               label_columns=None, final_test=0): 
    # Store the raw data.
    self.train_df = train_df
    self.val_df = val_df
    self.test_df = test_df
    self.final_test_df = final_test_df

    # Work out the label column indices.
    self.label_columns = label_columns
    if label_columns is not None:
      self.label_columns_indices = {name: i for i, name in
                                    enumerate(label_columns)}
    self.column_indices = {name: i for i, name in
                           enumerate(train_df.columns)}

    # Work out the window parameters.
    self.input_width = input_width
    self.label_width = label_width
    self.shift = shift

    self.total_window_size = input_width + shift

    self.input_slice = slice(0, input_width)
    self.input_indices = np.arange(self.total_window_size)[self.input_slice]

    self.label_start = self.total_window_size - self.label_width
    self.labels_slice = slice(self.label_start, None)
    self.label_indices = np.arange(self.total_window_size)[self.labels_slice]

  #ok so this is the tostring equivalent
  def __repr__(self):
    return '\n'.join([
        f'Total window size: {self.total_window_size}',
        f'Input indices: {self.input_indices}',
        f'Label indices: {self.label_indices}',
        f'Label column name(s): {self.label_columns}'])

w1 = WindowGenerator(input_width=24, label_width=1, shift=24,
                     label_columns=['month'])


w2 = WindowGenerator(input_width=6, label_width=1, shift=1,
                     label_columns=['month'])

print(w1)
print(' ')
print(w2)

def split_window(self, features):
  inputs = features[:, self.input_slice, :]
  labels = features[:, self.labels_slice, :]
  if self.label_columns is not None:
    labels = tf.stack(
        [labels[:, :, self.column_indices[name]] for name in self.label_columns],
        axis=-1)

  # Slicing doesn't preserve static shape information, so set the shapes
  # manually. This way the `tf.data.Datasets` are easier to inspect.
  inputs.set_shape([None, self.input_width, None])
  labels.set_shape([None, self.label_width, None])

  return inputs, labels

WindowGenerator.split_window = split_window

def plot(self, model=None, plot_col=column1, max_subplots=3, variation=0):
  inputs, labels = self.example
  plt.figure(figsize=(12, 8))
  plot_col_index = self.column_indices[plot_col]
  max_n = min(max_subplots, len(inputs))
  for n in range(max_n):
    plt.subplot(max_n, 1, n+1)
    #Lägger till en siffra
    plt.ylabel(f'{plot_col} [normed] {n + 1}')

    #Experimenterar
    q = n
    q += variation

    plt.plot(self.input_indices, inputs[q, :, plot_col_index],
             label='Inputs', marker='.', zorder=-10)

    if self.label_columns:
      label_col_index = self.label_columns_indices.get(plot_col, None)
    else:
      label_col_index = plot_col_index

    if label_col_index is None:
      continue
  
   
    plt.scatter(self.label_indices, labels[n, :, label_col_index],
                edgecolors='g', label='Labels', c='#2ca02c', s=64)
    if model is not None:
      predictions = model(inputs)
      plt.scatter(self.label_indices, predictions[n, :, label_col_index],
                  marker='X', edgecolors='g', label='Predictions',
                  c='#ff7f0e', s=64)

    if n == 0:
      plt.legend()

  plt.xlabel('Time [h]')

WindowGenerator.plot = plot

def make_dataset(self, data, batchSize=32):
  data = np.array(data, dtype=np.float32)
  ds = tf.keras.utils.timeseries_dataset_from_array(
      data=data,
      targets=None,
      sequence_length=self.total_window_size,
      sequence_stride=1,
      shuffle=True,
      batch_size=batchSize,)

  ds = ds.map(self.split_window)

  return ds

WindowGenerator.make_dataset = make_dataset

@property
def train(self):
  return self.make_dataset(self.train_df)

@property
def val(self):
  return self.make_dataset(self.val_df)

@property
def test(self):
  return self.make_dataset(self.test_df)

@property
def final_test(self):
  return self.make_dataset(self.final_test_df, batchSize=23)

@property
def example(self):
  """Get and cache an example batch of `inputs, labels` for plotting."""
  result = getattr(self, '_example', None)
  if result is None:
    # No example batch was found, so get one from the `.train` dataset
    result = next(iter(self.train))
    # And cache it for next time
    self._example = result
  return result

WindowGenerator.train = train
WindowGenerator.val = val
WindowGenerator.test = test
WindowGenerator.final_test = final_test
WindowGenerator.example = example

class Baseline(tf.keras.Model):
  def __init__(self, label_index=None):
    super().__init__()
    self.label_index = label_index

  def call(self, inputs):
    if self.label_index is None:
      return inputs
    result = inputs[:, :, self.label_index]
    return result[:, :, tf.newaxis]
    
val_performance = {}
performance = {}

# COMPILATION

#1 för mean absolute 
#2 för mean squared
option = 1
optimizer = tf.keras.optimizers.Adam()

#Från canvas
def last_time_step_mae(Y_true, Y_pred):
   return tf.keras.metrics.mean_absolute_error(Y_true[:, -1], Y_pred[:, -1])

def compile_and_fit(model, window, patience=2, option=option, optimizer=optimizer, MAX_EPOCHS=20):
  early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss',
                                                    patience=patience,
                                                    mode='min')
  inputSet = window.train
  if(option==1):
    model.compile(loss=tf.keras.losses.MeanAbsoluteError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[tf.keras.metrics.MeanAbsoluteError()])
  if(option==2):
      model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[tf.keras.metrics.MeanSquaredError()])
  if(option==3):
      model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[last_time_step_mae],
                run_eagerly=True)
      
  print(f'Option {option}')

  history = model.fit(inputSet, epochs=MAX_EPOCHS,
                      validation_data=window.val,
                      callbacks=[early_stopping])

  
  return history

# PLAYTIME
def playtime_compile(model, window, patience=2, option=option, optimizer=optimizer, MAX_EPOCHS=20, learningRate=0.0001,batchSize=32):
  early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss',
                                                    patience=patience,
                                                    mode='min')
  inputSet = window.train
  if(option==1):
    model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[tf.keras.metrics.MeanAbsoluteError()])
  if(option==2):
      model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[tf.keras.metrics.MeanSquaredError()])
  if(option==3):
      model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.Adam(),
                metrics=[last_time_step_mae])
      
  print(f'Option {option}')

  
  model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=learningRate),
              loss=tf.keras.losses.MeanSquaredError(),
              metrics=[last_time_step_mae])
  
  history = model.fit(inputSet, epochs=MAX_EPOCHS,
                      batch_size=batchSize,
                      validation_data=window.val,
                      callbacks=[early_stopping])
      
  return history

class MultiStepLastBaseline(tf.keras.Model):
  def call(self, inputs):
    return tf.tile(inputs[:, -1:, :], [1, OUT_STEPS, 1])

last_baseline = MultiStepLastBaseline()
last_baseline.compile(loss=tf.keras.losses.MeanSquaredError(),
                      metrics=[tf.keras.metrics.MeanAbsoluteError()])

multi_val_performance = {}
multi_performance = {}

class RepeatBaseline(tf.keras.Model):
  def call(self, inputs):
    return inputs

repeat_baseline = RepeatBaseline()
repeat_baseline.compile(loss=tf.keras.losses.MeanSquaredError(),
                        metrics=[tf.keras.metrics.MeanAbsoluteError()])

"""#Testing"""

# Change theese variables if switching between datasets
column1 = 'close'
column2 = 'clothes'
column3 = 'food'

OUT_STEPS = 24
IN_WIDTH = 24

CONV_WIDTH = 3

multi_window = WindowGenerator(input_width=IN_WIDTH,
                               label_width=OUT_STEPS,
                               shift=OUT_STEPS)

"""##Testgrupp #1

###Test #1
"""

wide_window = WindowGenerator(
    input_width=24, label_width=24, shift=12,
    label_columns=[column1])

wide_window

lstm_model = tf.keras.models.Sequential()
lstm_model.add(tf.keras.layers.LSTM(256, return_sequences=True))
lstm_model.add(tf.keras.layers.LSTM(64, return_sequences=True))
lstm_model.add(tf.keras.layers.Dense(units=1))

print(wide_window)

history = compile_and_fit(lstm_model, wide_window)



lstm_model.summary()

wide_window.label_columns
wide_window.plot(lstm_model, column1, 3, 3)

"""###Test #2"""

wide_window = WindowGenerator(
    input_width=60, label_width=60, shift=24,
    label_columns=[column1])

lstm_model = tf.keras.models.Sequential()
lstm_model.add(tf.keras.layers.LSTM(128, return_sequences=True))
lstm_model.add(tf.keras.layers.GRU(128, return_sequences=True))

lstm_model.add(tf.keras.layers.Dense(units=1))

#optimizer = tf.keras.optimizers.Nadam()

history = compile_and_fit(lstm_model, wide_window, optimizer=optimizer)

IPython.display.clear_output()

lstm_model.summary()

val_performance['LSTM'] = lstm_model.evaluate(wide_window.val)
performance['LSTM'] = lstm_model.evaluate(wide_window.test, verbose=0)

playtime = 100 - (100 * performance['LSTM'][1])

print("Andel genomsnittligt rätt = {:.2f}%".format(playtime))
print("Andel genomsnittligt fel  =  {:.2f}%".format(performance['LSTM'][1] * 100))

wide_window.plot(lstm_model, column1, 3, 5)

OUT_STEPS = 24
multi_window = WindowGenerator(input_width=24,
                               label_width=OUT_STEPS,
                               shift=OUT_STEPS)

multi_window.plot()
multi_window
multi_val_performance = {}
multi_performance = {}

multi_performance['AR LSTM'] = lstm_model.evaluate(multi_window.test, verbose=0)

x = np.arange(len(multi_performance))
width = 0.3

metric_name = 'mean_absolute_error'
metric_index = lstm_model.metrics_names.index('mean_absolute_error')
val_mae = [v[metric_index] for v in multi_val_performance.values()]
test_mae = [v[metric_index] for v in multi_performance.values()]

plt.bar(x - 0.17, val_mae, width, label='Validation')
plt.bar(x + 0.17, test_mae, width, label='Test')
plt.xticks(ticks=x, labels=multi_performance.keys(),
           rotation=45)
plt.ylabel(f'MAE (average over all times and outputs)')
_ = plt.legend()

"""###Test #3 (kan ta en liten stund)

####Test intro

OBS, för ssista delen i detta test måste test #1 ha körts, vi behöver histroy objektet.
"""

multi_window = WindowGenerator(input_width=IN_WIDTH,
                               label_width=OUT_STEPS,
                               shift=OUT_STEPS)

multi_window.plot()
multi_window

"""####Linjär"""

print(num_features)

multi_linear_model = tf.keras.Sequential([
    # Take the last time-step.
    # Shape [batch, time, features] => [batch, 1, features]
    tf.keras.layers.Lambda(lambda x: x[:, -1:, :]), # Vad gör lambda? det är någon beräkning. 
    # Shape => [batch, 1, out_steps*features]
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    # Shape => [batch, out_steps, features]
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(multi_linear_model, multi_window)

IPython.display.clear_output()

multi_val_performance['Linear'] = multi_linear_model.evaluate(multi_window.val)
multi_performance['Linear'] = multi_linear_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(multi_linear_model, variation=7)

"""####Kompakt"""

multi_dense_model = tf.keras.Sequential([
    # Take the last time step.
    # Shape [batch, time, features] => [batch, 1, features]
    tf.keras.layers.Lambda(lambda x: x[:, -1:, :]),
    # Shape => [batch, 1, dense_units]
    tf.keras.layers.Dense(512, activation='relu'),
    # Shape => [batch, out_steps*features]
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    # Shape => [batch, out_steps, features]
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(multi_dense_model, multi_window)

IPython.display.clear_output()

multi_val_performance['Dense'] = multi_dense_model.evaluate(multi_window.val)
multi_performance['Dense'] = multi_dense_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(multi_dense_model, variation=0)

"""####CNN"""

CONV_WIDTH = 3
multi_conv_model = tf.keras.Sequential([
    # Shape [batch, time, features] => [batch, CONV_WIDTH, features]
    tf.keras.layers.Lambda(lambda x: x[:, -CONV_WIDTH:, :]),
    # Shape => [batch, 1, conv_units]
    tf.keras.layers.Conv1D(256, activation='relu', kernel_size=(CONV_WIDTH)),
    # Shape => [batch, 1,  out_steps*features]
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    # Shape => [batch, out_steps, features]
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(multi_conv_model, multi_window)

IPython.display.clear_output()

multi_val_performance['Conv'] = multi_conv_model.evaluate(multi_window.val)
multi_performance['Conv'] = multi_conv_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(multi_conv_model, variation=0)

"""####RNN"""

multi_lstm_model = tf.keras.Sequential([
    # Shape [batch, time, features] => [batch, lstm_units].
    # Adding more `lstm_units` just overfits more quickly.
    tf.keras.layers.LSTM(32, return_sequences=False),
    # Shape => [batch, out_steps*features].
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    # Shape => [batch, out_steps, features].
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(multi_lstm_model, multi_window)

IPython.display.clear_output()

multi_val_performance['LSTM'] = multi_lstm_model.evaluate(multi_window.val)
multi_performance['LSTM'] = multi_lstm_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(multi_lstm_model, variation=1)

"""####AR LSTM"""

class FeedBack(tf.keras.Model):
  def __init__(self, units, out_steps):
    super().__init__()
    self.out_steps = out_steps
    self.units = units
    self.lstm_cell = tf.keras.layers.LSTMCell(units)
    # Also wrap the LSTMCell in an RNN to simplify the `warmup` method.
    self.lstm_rnn = tf.keras.layers.RNN(self.lstm_cell, return_state=True)
    self.dense = tf.keras.layers.Dense(num_features)

feedback_model = FeedBack(units=32, out_steps=OUT_STEPS)

def warmup(self, inputs):
  # inputs.shape => (batch, time, features)
  # x.shape => (batch, lstm_units)
  x, *state = self.lstm_rnn(inputs)

  # predictions.shape => (batch, features)
  prediction = self.dense(x)
  return prediction, state

FeedBack.warmup = warmup

prediction, state = feedback_model.warmup(multi_window.example[0])
prediction.shape

def call(self, inputs, training=None):
  # Use a TensorArray to capture dynamically unrolled outputs.
  predictions = []
  # Initialize the LSTM state.
  prediction, state = self.warmup(inputs)

  # Insert the first prediction.
  predictions.append(prediction)

  # Run the rest of the prediction steps.
  for n in range(1, self.out_steps):
    # Use the last prediction as input.
    x = prediction
    # Execute one lstm step.
    x, state = self.lstm_cell(x, states=state,
                              training=training)
    # Convert the lstm output to a prediction.
    prediction = self.dense(x)
    # Add the prediction to the output.
    predictions.append(prediction)

  # predictions.shape => (time, batch, features)
  predictions = tf.stack(predictions)
  # predictions.shape => (batch, time, features)
  predictions = tf.transpose(predictions, [1, 0, 2])
  return predictions

FeedBack.call = call

print('Output shape (batch, time, features): ', feedback_model(multi_window.example[0]).shape)

history = compile_and_fit(feedback_model, multi_window)

IPython.display.clear_output()

multi_val_performance['AR LSTM'] = feedback_model.evaluate(multi_window.val)
multi_performance['AR LSTM'] = feedback_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(feedback_model)

multi_window.plot(feedback_model, plot_col=column1)

"""###Test #4"""

multi_gru_model = tf.keras.Sequential([
    tf.keras.layers.GRU(32, return_sequences=False, return_state=False),

    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(multi_gru_model, multi_window)

IPython.display.clear_output()

multi_val_performance['GRU'] = multi_gru_model.evaluate(multi_window.val)
multi_performance['GRU'] = multi_gru_model.evaluate(multi_window.test, verbose=0)
multi_window.plot(multi_gru_model, variation=10)

"""##Testgrupp #2

###Test #5
"""

model_combo1 = tf.keras.Sequential([
    tf.keras.layers.Lambda(lambda x: x[:, -CONV_WIDTH:, :]),
    tf.keras.layers.Conv1D(196, activation='relu', kernel_size=(CONV_WIDTH)),
    tf.keras.layers.GRU(32, return_sequences=True, return_state=False),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.LSTM(32, return_sequences=False),
    
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(model_combo1, multi_window)

multi_val_performance['Combo1'] = model_combo1.evaluate(multi_window.val)
multi_performance['Combo1'] = model_combo1.evaluate(multi_window.test, verbose=0)
multi_window.plot(model_combo1, variation=0)

"""###Test #6"""

# Den bästa modellen framtränad av keras tuner
model_combo2 = tf.keras.Sequential([
    tf.keras.layers.GRU(32, return_sequences=True, return_state=False),
    tf.keras.layers.LSTM(96, return_sequences=False),
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(model_combo2, multi_window)

multi_val_performance['model_combo2'] = model_combo2.evaluate(multi_window.val)
multi_performance['model_combo2'] = model_combo2.evaluate(multi_window.test, verbose=0)
multi_window.plot(model_combo2, variation=0)

"""###Test #7"""

# Den bästa modellen framtränad av keras tuner
# men hur ändrar man batch size?
model_gru_optimised = tf.keras.Sequential([
    tf.keras.layers.GRU(288, return_sequences=True, return_state=False),
    tf.keras.layers.GRU(416, return_sequences=False, return_state=False),
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = playtime_compile(model_gru_optimised, multi_window, learningRate=0.0001, batchSize=416)

multi_val_performance['model_gru_optimised'] = model_gru_optimised.evaluate(multi_window.val)
multi_performance['model_gru_optimised'] = model_gru_optimised.evaluate(multi_window.test, verbose=0)
multi_window.plot(model_gru_optimised, variation=0)

"""###Test #8"""

second_best_gru = tf.keras.Sequential([
    tf.keras.layers.GRU(288, return_sequences=True, return_state=False),
    tf.keras.layers.GRU(416, return_sequences=False, return_state=False),
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(second_best_gru, multi_window)

IPython.display.clear_output()

multi_val_performance['second_best_gru'] = second_best_gru.evaluate(multi_window.val)
multi_performance['second_best_gru'] = second_best_gru.evaluate(multi_window.test, verbose=0)
multi_window.plot(second_best_gru, variation=0)

"""###Test #9"""

best_gru = tf.keras.Sequential([
    tf.keras.layers.GRU(704, return_sequences=False, return_state=False),
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
])

history = compile_and_fit(best_gru, multi_window)

IPython.display.clear_output()

multi_val_performance['best_gru'] = best_gru.evaluate(multi_window.val)
multi_performance['best_gru'] = best_gru.evaluate(multi_window.test, verbose=0)
multi_window.plot(best_gru, variation=0)

"""##Modeljämförelse"""

x = np.arange(len(multi_performance))
width = 0.3

metric_name = 'mean_absolute_error'
metric_index = lstm_model.metrics_names.index('mean_absolute_error')
val_mae = [v[metric_index] for v in multi_val_performance.values()]
test_mae = [v[metric_index] for v in multi_performance.values()]

plt.bar(x - 0.17, val_mae, width, label='Validation')
plt.bar(x + 0.17, test_mae, width, label='Test')
plt.xticks(ticks=x, labels=multi_performance.keys(),
           rotation=45)
plt.ylabel(f'MAE (average over all times and outputs)')
_ = plt.legend()

for name, value in multi_performance.items():
  print(f'{name:8s}: {value[1]:0.4f}')

second_best_gru.summary()

"""##Bayesian"""

# Experimental model, compiled with new fun method
def build_bayesian(hp): 
    model = tf.keras.Sequential([
    tf.keras.layers.Conv1D(filters=hp.Int('conv_1_filter', min_value=32, max_value=256, step=32), activation='relu', kernel_size=(CONV_WIDTH)),
    tf.keras.layers.GRU(units=hp.Int('GRU_units', min_value=32, max_value=256, step=32), return_sequences=True, return_state=False),
    tf.keras.layers.Dense(units=hp.Int('dense1_units', min_value=32, max_value=256, step=32), activation='relu'),
    tf.keras.layers.LSTM(units=hp.Int('LSTM_units', min_value=32, max_value=256, step=32), return_sequences=False),
    
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(hp.Choice('learning_rate', values=[1e-2, 1e-4])),
              loss=tf.keras.losses.MeanAbsoluteError(),
              metrics=['mean_absolute_error'])

    return model

def build_bayesian_GRU(hp): 
    model = tf.keras.Sequential([
    tf.keras.layers.GRU(units=hp.Int('GRU_units', min_value=32, max_value=1024, step=32), return_sequences=False, return_state=False),
    tf.keras.layers.Dense(OUT_STEPS*num_features,
                          kernel_initializer=tf.initializers.zeros()),
    tf.keras.layers.Reshape([OUT_STEPS, num_features])
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(hp.Choice('learning_rate', values=[1e-2, 1e-4])),
              loss=tf.keras.losses.MeanAbsoluteError(),
              metrics=['mean_absolute_error'])

    return model

MAX_TRIALS = 20 
EXECUTION_PER_TRIAL = 2

class MyTuner(keras_tuner.tuners.BayesianOptimization):
  def run_trial(self, trial, *args, **kwargs):
    # You can add additional HyperParameters for preprocessing and custom training loops
    # via overriding `run_trial`
    kwargs['batch_size'] = trial.hyperparameters.Int('batch_size', 32, 512, step=32, default=256)
    return super(MyTuner, self).run_trial(trial, *args, **kwargs)

# Bayesian search which also searches for batch_size from lab 1
tuner = MyTuner(
    build_bayesian_GRU, 
    max_trials=MAX_TRIALS,
    objective='mean_absolute_error',
    #direction="min",
    executions_per_trial=EXECUTION_PER_TRIAL,
    directory='output',
    overwrite=True,
    num_initial_points=10, # Start with 10 random points and then do more structured search
    project_name='CPI_params'
)

noepochauto = 6
es = tf.keras.callbacks.EarlyStopping('val_loss', patience=2, restore_best_weights = True)

tuner.search(multi_window.train, 
             epochs=noepochauto, 
             validation_data=(multi_window.val), 
             callbacks=[es])

model = tuner.get_best_models(num_models=1)[0]
vals = tuner.get_best_hyperparameters(num_trials=5)[4].values
for keys,values in vals.items():
    print('%20s = %3.4g' %(keys,values))
    
model.summary()

"""#Prediction"""

multi_window = WindowGenerator(input_width=509,
                               label_width=1,
                               shift=3)

pred = second_best_gru.predict(multi_window.test)
#eval = second_best_gru.evaluate(multi_window.final_test)

print(pred.shape)

# Denna kod ger en bra bild men massor felmeddelande text

# multi_window.plot(second_best_gru, variation=0, max_subplots=1)

# Borde de-normalize datan men löser det inte av någon anledning

#print(reshapeOne.shape)
#print(pred.shape)

ny_pred = []
# ny_pred = (pred[0][0] + reshapeOne) * reshapeTwo

# ny_pred = (pred + kpi_df.mean()) * kpi_df.std()

toPlot = pred[-1][:]

plt.plot(toPlot)

plt.show()

savedTest[-12:]

print(pred.shape)
for x in pred[-5:][-3]:
  print(x)

# okej, problem, vad är vad i denna 4d array, tensor, som enligt shape tidigare bara skulle innehålla 3 dimensioner. Eftersom fönstret (med 24 i bredd, input) vi skickar in till predict
# har shift 3 betyder det att den returnerar en 24 lång serie värden som skiftar 3 steg åt höger, därmed predict() funtkionen. pred nedan innehåller 489 * 24 input-slingor med datum och värden.
# Vart kommer 489 ifrån? i test finns 515 värden, 515-24 = 491 så det är inte något med input. Eller är det så att predict() tar 24 en serie, klipper ut, predikterar 489 nya värden. Okej det var
# direkt relaterat till längden på tidsserien.


val0 = pred[:][-4][-1][-1]
val1 = pred[:][-3][-1][-1]
val2 = pred[:][-2][-1][-1]
val3 = pred[:][-1][-1][-1]

print(f'{val0} {val1} {val2} {val3}')

# val0 == december value in decimals

# make them mean
valMean = (val1 + val2 + val3) / 3
print(valMean)
# get difference between value zero and the mean value.

valDiff = valMean / val0
print(f'{valDiff} issit working')

resultGet = savedTest['close'][514]
print(f'last entry in test data {resultGet} which is the KPI value for november')

# prediction for december 
predictionResultValue = hello * valDiff
roundedVal = round(predictionResultValue, 2)

print(f'raw prediction result: {predictionResultValue} and rounded: {roundedVal}')
print(f'now inflation is calculated based on the difference from the year before measure date which means that i should divide the value from december last year by this years value to get inflation percentage')

lastYearval = savedTest['close'][503] # see the table from datafram savedtest
print(lastYearval)
inflationPredictionPercentage = predictionResultValue / lastYearval
inflationPredictionPercentage = round(inflationPredictionPercentage, 2)
print(f'Inflationsprocent: {inflationPredictionPercentage}')